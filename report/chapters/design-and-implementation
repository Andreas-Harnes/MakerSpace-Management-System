\chapter{Design and Implementation}
This chapter will go over all the technical documentation needed to maintain and understand the system. In addition to this documentation this chapter will also contain information about how the system was built and what technologies that was used to create the system.
The System is divided into two sections; the frontend and the backend. The frontend is where all the graphical user interfaces are and where all the interactions with the user will be. The backend will handle all the computing of the data that gets sent from the frontend and the data from the database. These two system are communicating through an API (Application Programming Interface).

\todo{Skriv overordnet om hvordan systemet henger sammen og deretter for hver enkelt komponent}

\section{Frontend}

The frontend of the application a SPA (Single Page Application) built by using HTML (Hyper Text Markup Language), JavaScript, vue.JS and Sass (Syntactically awesome style sheets).
Vue.JS (See chapter 2.3.1) was used to create the structure, layout and content of the application. For the styling of the application Scss was used (See chapter 2.3.5). 

\subsection{Single Page Application}
Single Page Applications are web applications where a single HTML page is loaded and the content of that page is dynamically updated as the user interacts with the page. By doing this web application does not have to reload for every user interaction and can create a more fluent experience for the user.

\begin{figure}[h]
    \centering
    \includegraphics[width=115mm,scale=1]{figures/spa_lifecycle.png}
    \caption{The Traditional Page Lifecycle vs. the SPA Lifecycle}
    \label{fig:SPAs_lifecycle}
\end{figure}

The project application can be divided into two parts; the header and the body. These two parts are two individual places where components can be loaded and displayed to the user. The header part will always display the header component and stay at the top of the web application. The body part is the part of the web application that will be dynamically changed out based on the user interaction.

\subsection{Components}


\subsection{Wireframes}

\subsection{Style sheet}
For this project it will be used the .scss files ending. It have been made a directory where it will be collected some of the SCSS. The directory contains of files as \_btn.scss (for buttons), \_colors.scss (for storing colors), \_style.scss (for other universal rules), and \_media.scss where all off the responsive SCSS will be collected (for different platforms as mobile, tablet etc..).

One of the strongest sides of Vue.js, is that in the vue files, it gives permission to 
defining style tags to be what can be called "scoped". With that it means that the SASS that will be written inside the style that is set to scoped, will only apply to that component. The group have been taking advantage of this and have for example all SASS that belongs to the header file, written in header style tag, and what belongs to body in the body files. Other tings as rules that suits several different files, is kept in separate files. 

The group also have a separate file as mention, that is called \_media.scss. This is where all the SASS for different platforms as mobile, tablets and different PC screens is written. This because it becomes more transparent when working with only the responsive design. The screen size that the group has been working on is:

\begin{itemize}
  \item Phones (320 x 600)
  \item Tablets (768 x 1024)
  \item Screen (720 x 1280)
  \item Screen (1080 x 1920)
  \item Screen (1440 x 2560)
\end{itemize}

\section{Backend}
The backend operates on the JavaScript runtime enviroment provided by Node.js.
The backend uses the default Node.js package manager NPM.
There are many packages used in the backend but the most prominent of them is the web application framework Express.js.
The routing Express.js provides is used for all endpoints in the application.
\todo{Resources cannot be deleted or updated etc.}
The endpoints provides clients with the ability to create, read, update, or delete resources stored on the backend.
There are several endpoints provided by the backend.

\subsection{Endpoints}
User registration is achieved through an endpoint.
In order to register a new user the client has to send a POST request to the endpoint at /users/signup.
The backend is implemented with input validation.
Therefore the request must contain the necessary fields when requesting the backend to create a new account.
The required fields are email, password, phone, firstName and lastName.
The backend will return an HTTP status code of 400(bad request) should the client fail to provide the necessary fields.
After having validated the input provided by the client the backend verifies that the email has not been registered before.
If the email has been registered before the backend responds with an HTTP status code of 409(conflict).
If the email has not been registered before the backend creates the new user and sends a response with an HTTP status of 201.

Login is also achieved through an endpoint.
In order to login the client has to send a POST request to the endpoint at /users/signin.
The request must contain the two required fields; email and password.
The backend will return an HTTP status code of 400(bad request) should the client fail to provide the necessary fields or the fields be in an improper format.
After having validated the input provided by the client the backend compares the information provided by the client with the one stored in the database.
If the two match the backend returns an HTTP status code of 200 and the user is logged in.
If they do not match the backend returns an HTTP status code of 401(unauthorized).

Finally logout is also achieved through an endpoints.
In order to logout the client has to send a GET request to the endpoint at /users/signout.
As the request is a GET request it cannot contain any fields so unlike the user registration route and the user login route the logout route does not require any fields to be present.
The request must however contain a valid session ID in the "mms\_sid" cookie as the backend needs to know which user to log out.
When the user has been logged out the session ID is invalidated, and the server responds with an HTTP status of 200.
Failure of the client to send the aforementioned cookie, or sending an expired or otherwise invalid cookie, will result in a response with an HTTP status of 401(unauthorized).

Fetching items as well as categories for items stored in the application is also achieved through an endpoint.
The client has to send a GET request to the endpoint at /cumulativeitems.
The request is not required to contain any fields or any other information.
The request may optionally however contain one or more 'category' query parameter.
The backend only accepts integers as parameters; any other value is ignored.
The integer represents the ID of a category.
The parameter is used to filter items based on their category ensuring only items matching the category are included in the response.
The request may also optionally contain one 'start' query parameter.
The backend once again also only accepts integers as parameters.
The integer represents the offset in the list of items.
The backend always returns a maximum of 25 items in order to preserve network usage.
Only the items stored in the slots 1-25 will be returned should there be more than 25 items stored in the database and no 'start' parameter is specified.
The 'start' parameter may be used to change the slots returned in the response.
For instance when start is set to 5 the items in slots 6-30 will be returned.
The categories 
The request will only return one of two responses; the server may respond with an HTTP status of 200 along with the appropriate items, or it may respond with an HTTP status of 500(internal server error).
The later only occurs should something go wrong - such as the backend being unable to access the database.

\subsection{Restricted endpoints}
The backend is designed with access restrictions on the resources it provides.
Users authenticate themselves using their session ID.
The backend generates a unique session ID when the user successfully registers a new user, or when a user successfully logs in.
This means the backend does not uniquely identify any users before registering a user or before a user logs in.
The backend stores the session ID in a local SQLite database
The backend also creates a cookie named "mms\_sid" which stores the session ID.
The cookie is sent to the client, and on each subsequent request to an endpoint(or until logout) the client sends its cookie containing the session ID.
The backend uses the cookie to authenticate the user.
This ensures protected resources(resources that are only available to a subset of the total number of users) remain confidential and inaccessible to unauthorized or unauthenticated users.
There are currently no restricted routes, but given the fact the backend already has an implementation for the required authentication functionality, adding such restrictions on new or already existing routes would be trivial using the authentication middleware.
The backend has thus been designed and implemented with extendability in mind - which was one of the desirable traits for the project.

\section{Connection}
The frontend and the backend currently communicate using an HTTP connection.
The group initially wanted the frontend and the backend to communicate using an HTTPS connection as one should always use HTTPS connections \cite{google_always_https}.
HTTPS was not implemented however as the application was to be hosted on the colleges servers and the system administrators of the college system were unable to provide us with the necessary environment required for us to implement HTTPS due to juridical reasons.
HTTPS will therefore have to be implemented in the aftermath of the project.

Using POST instead of request header ...

\section{Database}
The database as implemented consists of the following tables:
\begin{enumerate}
    \item Users.
    This table holds information about the users such as their name and their email.
    For a full list of fields see figure \ref{fig:db-tables}.
    \item Categories.
    This table stores the categories used to categorize the items.
    The table is illustrated in figure \ref{fig:db-tables}
    \item CumulativeItems.
    This table stores general information regarding an item such as its name along with a description and an image of it.
    This table is also illustrated in figure \ref{fig:db-tables}.
    \item SpecificItems.
    This table stores information regarding a given existing item.
    The status indicates the availability of the item; a value of 0 indicates the item is unavailable and a value of 1 indicates the item is available.
    The status may be expanded in the future to represent more states than the ones listed here with states such as "out for maintenance", "missing" or "stolen".
    Finally this table is also illustrated in figure \ref{fig:db-tables}.
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[width=120mm,scale=1]{figures/datamodel_ba.png}
    \caption{Database tables with their relations}
    \label{fig:db-tables}
\end{figure}

All fields are stored in plain text in the database with the exception of the user's password as storing passwords in plain text is considered poor security practice \cite{plaintext-passwords-poor-practice}.
There are several reasons for this:
\begin{itemize}
    \item Employees(with access to the database) will have access to the passwords.
    \item In the event of a security breach the intruders may be able to extract the passwords from the database.
    \item In the event of a database leak the passwords will be accessible to everyone.
\end{itemize}

Malicious actors would be able to authenticate as other users in the MakerSpace Management System should they have access to the passwords.
As such the malicious actors would be able to extract information from the victims, or perform actions on their behalf - actions the victims perhaps would not otherwise do.
Even worse the malicious actors would be able to authenticate as others users on other platforms as many users reuse the same password across services \cite{reuse-passwords}.

For the aforementioned reasons the group has taken extra care when storing passwords.
The backend uses the NPM package bcrypt.js.
The passwords go through the following process; they are first salted, then the salted password is hashed and lastly the salted and hashed password has the salt prepended to it.
For example:
\begin{enumerate}
    \item The user enters his password theUs3rP!assw0rd.
    \item The backend hands the user password to bcrypt.js and it generates the salt:
    
    \$2b\$12\$304a14Olae2ZToKVeAk9zO.

    The value has three different fields separated by a \$.
    The first field (in this case "2b") represents the bcrypt algorithm version used to generate the hash.
    The second field (in this case "12") represents the cost factor.
    The third field (in this case "304a14Olae2ZToKVeAk9zO") represents the actual salt.

    \item bcrypt.js adds the salt to the password and hashes it.
    The hashed password is:

    rfmhWJ/IFZl0eEJZS5KkxVl.T5W4N3K. 
    \item The hashed password has the salt prepended to it which results in the following value:

    \$2b\$12\$304a14Olae2ZToKVeAk9zOrfmhWJ/IFZl0eEJZS5KkxVl.T5W4N3K.
    \item bcrypt.js returns the password to the backend and the backend stores it in the MariaDB.

\end{enumerate}